package com.frysning.springdnd.combiner;import com.fasterxml.jackson.annotation.JsonIgnore;import com.frysning.springdnd.action.CalculatedAction;import com.frysning.springdnd.enemy.CalculatedSavingThrow;import com.frysning.springdnd.enemy.Enemy;import com.frysning.springdnd.language.Language;import com.frysning.springdnd.modifier_type.ModifierType;import com.frysning.springdnd.race.Race;import com.frysning.springdnd.size.Size;import com.frysning.springdnd.stats.ReadableStats;import com.frysning.springdnd.stats.Stat;import com.frysning.springdnd.trait.ReadableTrait;import com.frysning.springdnd.trait.Trait;import com.frysning.springdnd.speed.Speed;import java.util.*;import java.util.stream.Collectors;import static com.frysning.util.Predicates.distinctBy;import static java.util.Comparator.comparingInt;public class Combined {	Enemy enemy;	Race race;	public Combined(Enemy enemy, Race race) {		this.enemy = enemy;		this.race = race;	}	@JsonIgnore	public Enemy enemy() {		return enemy;	}	@JsonIgnore	public Race race() {		return race;	}	public String getName() {		return enemy.getName();	}	public String getRaceName() {		return race.getName();	}	public String getRaceType() {		return enemy.getRaceType().getName();	}	public ReadableStats getBaseStats() {		return enemy.getBaseStats();	}	public Stat getRacialStats() {		return race.getStat();	}	public ReadableStats getCombinedStats() {		return new ReadableStats(enemy.getStat(), race.getStat());	}	public List<CalculatedAction> getCalculatedActions() {		return enemy.getActions().stream()				.map(						action -> new CalculatedAction(action, getCombinedStats(),								enemy.getProficiencyBonus(), this.getName()))				.collect(						Collectors.toList());	}	public List<CalculatedAction> getCalculatedReactions() {		return enemy.getReactions().stream()				.map(						action -> new CalculatedAction(action, getCombinedStats(),								enemy.getProficiencyBonus(), this.getName()))				.collect(						Collectors.toList());	}	public String getArmorClass() {		return enemy.getAc();	}	public List<Speed> getSpeed() {		var speedCollection = enemy.getSpeed();		//Remove duplicates		speedCollection.removeAll(race.getSpeed());		//Add new set of values		speedCollection.addAll(race.getSpeed());		return speedCollection				.stream()				.sorted(comparingInt(Speed::getRange).reversed())				.filter(distinctBy(Speed::getSpeedTypeId))				.collect(Collectors.toList());	}	public int getProficiencyBonus() {		return enemy.getProficiencyBonus();	}	public Size getSize() {		if (enemy.getSize().id != race.getSize().getId()) {			return race.getSize();		} else {			return enemy.getSize();		}	}	public String getHitDice() {		return enemy.getHitDice();	}	public String getAlignment() {		return enemy.getAlignment();	}	public int getDefaultHitPoints() {		return enemy.getDefaultHitPoints();	}	public List<CalculatedSavingThrow> getCalculatedSavingThrows() {		return enemy.getSavingThrows().stream().map(				modifierId -> new CalculatedSavingThrow(ModifierType.getById(modifierId),						getCombinedStats(),						enemy().getProficiencyBonus())).collect(				Collectors.toList());	}	public List<Language> getLanguages() {		List<Language> enemyLanguages = enemy.getLanguages();		List<Language> raceLanguages = race.getLanguages();		enemyLanguages.removeAll(raceLanguages);		enemyLanguages.addAll(raceLanguages);		return enemyLanguages;	}	public List<ReadableTrait> getReadableTraits() {		List<Trait> traits = enemy.getTraits();		traits.removeAll(race.getTraits());		traits.addAll(race.getTraits());		return traits.stream()				.map(trait -> new ReadableTrait(trait, getCombinedStats(), getProficiencyBonus(),						this.getName()))				.collect(						Collectors.toList());	}	//Weakness	//Immunities	//Resistances}